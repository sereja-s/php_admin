Классы, функции, свойства Принципы ООП (наследование, полиморфизм, инкапсуляция)
---------------------------------------------------------------------------------

в файле index.php:
-------------------


class Grandpa
{
	//определим (объявим, опишем) свойства со спецификатором доступа: public и зададим им значение
	public $hair = 'русые';
	public $body = 'нормальное';
	//определим (объявим, опишем) свойство со спецификатором доступа: protected и зададим свойству значение
	// (спецификатор доступа protected делает доступным свойство только внутри класса, в котором оно объявлено или внутри дочерних классов)
	protected $nose = 'кривой';

	private $lips = 'полные';

	private $borsch = 'вкусный';

	//определим (объявим) метод (функцию) в параметры которой передадим переменную $calories:
	public function eat($calories)
	{
		if ($calories > 2000) {
			$this->body = 'толстый'; // обращаемся к методу (функции) или свойству класса внутри класса с использованием ключевого слова: $this 
			//(При этом обращение к методу (функции) класса внутри этого класса, надо делать заключив её в другую функцию, а не просто в теле класса)
		} else {
			$this->body = 'стройный';
		}
	}

	public function showGrandpaLips()
	{
		echo $this->lips;
	}

	// Принцип ПОЛИМОРФИЗМА (возможность переопределить и (или) дополнить метод (функцию) родительского класса)- 
	// для этого нужно в дочернем классе создать одноимённую функцию со спецификатором доступа public в которой можно переопределить и (или) дополнить метод (функцию) родительского класса:
	// определим (объявим) метод (функцию) со спецификатором доступа protected:
	protected function getBorsch()
	{
		return $this->borsch; // чтобы переменную переопределять, её нужно вернуть
	}
}

// принцип наследования:
class Father extends Grandpa
{
	public function showGrandpaNose()
	{
		echo $this->nose;
	}

	// принцип ИНКАПСУЛЯЦИИ (чтобы случайно не изменить свойство, делаем его защищённым спецификатором доступа)
	protected $eyes = 'голубые';
	// При необходимости внесения изменений, объявляется специальная функция для этого (её можно будет вызывать для совешения прописанного в ней действия, например обращаясь через объект класса):
	public function reColor($color)
	{
		$this->eyes = $color;
		echo $this->eyes;
	}


	// одноимённая функция со спецификатором доступа public в которой можно переопределить и (или) дополнить метод (функцию) родительского класса
	public function getBorsch()
	{
		// 1- получаем (сохраняем) в переменную запрос результата работы функции родительского класса (содержимое переменной родительского класса):
		$borsch = parent::getBorsch();
		// 2- теперь можем переопределить и (или) дополнить переменную:
		$borsch .= ' и солёный';
		// 3- выведем уже дополненную переменную
		echo $borsch;
		// 3- чтобы иметь возможность и дальше изменять переменную (например через объёкт класса) её нужно вернуть:
		return $borsch;
	}
}

// создадим объекты класса Man ( с помощью конструкции new):
$masha = new Father();
$ivan = new Father();
$petya = new Father();

// выведем на экран свойства объектов класса (посмотрим какие волосы у Маши):
// обращаемся к объекту, затем к его свойству (знак $ здесь не указываем):
echo 'Волосы Маши - ' . $masha->hair . '<br>'; // точка здесь- знак конкатенации (прибавления)
echo 'Волосы Ивана - ' . $ivan->hair . '<br>';

// обратимся к объекту, затем к его свойству и меняем это свойство (присваиваем ему новое значение):
$masha->hair = 'белые';

echo 'Волосы Маши - ' . $masha->hair . '<br>';
echo 'Волосы Ивана - ' . $ivan->hair . '<br>';

echo 'Тело Маши - ' . $masha->body . '<br>';
echo 'Тело Ивана - ' . $ivan->body . '<br>';

// обратимся через объекты класса к функции класса и передадим в неё новые значения (здесь- количество калорий)
$masha->eat(700);
$ivan->eat(2700);
echo 'Тело Маши - ' . $masha->body . '<br>';
echo 'Тело Ивана - ' . $ivan->body . '<br>';
echo 'Тело Пети - ' . $petya->body . '<br>';

//$masha->nose; //обратиться к свойству со спецификатором доступа: protected нельзя вне класса в котором оно объявлено
// но можем получить свойство, используя функцию, объявленную в дочернем классе (родной для нашего объекта):
$masha->showGrandpaNose() . '<br>';
$masha->showGrandpaLips() . '<br>';  // сработает только если свойство lips, имееющее спецификатор доступа private будет находиться в методе (здесь- showGrandpaLips()) из того же класса

$masha->getBorsch() . '<br>'; // получим результат работы функции (например вывод результата (уже дополненной в вызываемой функции переменную))

// переопределим (дополним) полученную переменную ещё раз:
$borsch = $masha->getBorsch();
echo $borsch . ' и сладкий' . '<br>';

// внесём изменения в защищённое свойсто (по принципу инкапсуляции) передав новое значение в параметры созданной для этого функции:
$masha->reColor('белые');

// Абстрактный класс нужен для передачи своего функционала и свойств дочерним классам (наследникам) и является частью чего то большего 
// (отдельное существование АК не имеет смысла (необходимости) и создать объект абстрактного класса не возможно)
// объявляется он следующимм образом:
abstract class Classabstract
{
}
// затем объявляется наследующий его класс (дочерний) 
// Он полчает все возможности родительского класса и уже от этого класса создаются объекты:
class Naslednik extends Classabstract
{
}
